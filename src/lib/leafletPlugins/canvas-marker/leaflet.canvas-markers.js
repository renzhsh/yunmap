(function (modules) { // webpackBootstrap
    // The module cache
    var installedModules = {};

    // The require function
    function __webpack_require__(moduleId) {

        // Check if module is in cache
        if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
        }
        // Create a new module (and put it into the cache)
        var module = installedModules[moduleId] = {
            i: moduleId,
            l: false,
            exports: {}
        };

        // Execute the module function
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

        // Flag the module as loaded
        module.l = true;

        // Return the exports of the module
        return module.exports;
    }


    // expose the modules object (__webpack_modules__)
    __webpack_require__.m = modules;

    // expose the module cache
    __webpack_require__.c = installedModules;

    // define getter function for harmony exports
    __webpack_require__.d = function (exports, name, getter) {
        if (!__webpack_require__.o(exports, name)) {
            Object.defineProperty(exports, name, { enumerable: true, get: getter });
        }
    };

    // define __esModule on exports
    __webpack_require__.r = function (exports) {
        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
            Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
        }
        Object.defineProperty(exports, '__esModule', { value: true });
    };

    // create a fake namespace object
    // mode & 1: value is a module id, require it
    // mode & 2: merge all properties of value into the ns
    // mode & 4: return value when already ns object
    // mode & 8|1: behave like require
    __webpack_require__.t = function (value, mode) {
        if (mode & 1) value = __webpack_require__(value);
        if (mode & 8) return value;
        if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
        var ns = Object.create(null);
        __webpack_require__.r(ns);
        Object.defineProperty(ns, 'default', { enumerable: true, value: value });
        if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) { return value[key]; }.bind(null, key));
        return ns;
    };

    // getDefaultExport function for compatibility with non-harmony modules
    __webpack_require__.n = function (module) {
        var getter = module && module.__esModule ?
 			function getDefault() { return module['default']; } :
 			function getModuleExports() { return module; };
        __webpack_require__.d(getter, 'a', getter);
        return getter;
    };

    // Object.prototype.hasOwnProperty.call
    __webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

    // __webpack_public_path__
    __webpack_require__.p = "";


    // Load entry module and return exports
    return __webpack_require__(__webpack_require__.s = 0);
})
/************************************************************************/
([
/* 0 */
/***/ (function (module, exports, __webpack_require__) {

    var rbush = __webpack_require__(1);
    var factory = __webpack_require__(3);

    window.L.CanvasIconLayer = factory(L);
    window.rbush = rbush;


    /***/
}),
/* 1 */
/***/ (function (module, exports, __webpack_require__) {

    "use strict";


    module.exports = rbush;
    module.exports.default = rbush;

    var quickselect = __webpack_require__(2);

    function rbush(maxEntries, format) {
        if (!(this instanceof rbush)) return new rbush(maxEntries, format);

        // max entries in a node is 9 by default; min node fill is 40% for best performance
        this._maxEntries = Math.max(4, maxEntries || 9);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

        if (format) {
            this._initFormat(format);
        }

        this.clear();
    }

    rbush.prototype = {

        all: function () {
            return this._all(this.data, []);
        },

        search: function (bbox) {

            var node = this.data,
                result = [],
                toBBox = this.toBBox;

            if (!intersects(bbox, node)) return result;

            var nodesToSearch = [],
                i, len, child, childBBox;

            while (node) {
                for (i = 0, len = node.children.length; i < len; i++) {

                    child = node.children[i];
                    childBBox = node.leaf ? toBBox(child) : child;

                    if (intersects(bbox, childBBox)) {
                        if (node.leaf) result.push(child);
                        else if (contains(bbox, childBBox)) this._all(child, result);
                        else nodesToSearch.push(child);
                    }
                }
                node = nodesToSearch.pop();
            }

            return result;
        },

        collides: function (bbox) {

            var node = this.data,
                toBBox = this.toBBox;

            if (!intersects(bbox, node)) return false;

            var nodesToSearch = [],
                i, len, child, childBBox;

            while (node) {
                for (i = 0, len = node.children.length; i < len; i++) {

                    child = node.children[i];
                    childBBox = node.leaf ? toBBox(child) : child;

                    if (intersects(bbox, childBBox)) {
                        if (node.leaf || contains(bbox, childBBox)) return true;
                        nodesToSearch.push(child);
                    }
                }
                node = nodesToSearch.pop();
            }

            return false;
        },

        load: function (data) {
            if (!(data && data.length)) return this;

            if (data.length < this._minEntries) {
                for (var i = 0, len = data.length; i < len; i++) {
                    this.insert(data[i]);
                }
                return this;
            }

            // recursively build the tree with the given data from scratch using OMT algorithm
            var node = this._build(data.slice(), 0, data.length - 1, 0);

            if (!this.data.children.length) {
                // save as is if tree is empty
                this.data = node;

            } else if (this.data.height === node.height) {
                // split root if trees have the same height
                this._splitRoot(this.data, node);

            } else {
                if (this.data.height < node.height) {
                    // swap trees if inserted one is bigger
                    var tmpNode = this.data;
                    this.data = node;
                    node = tmpNode;
                }

                // insert the small tree into the large tree at appropriate level
                this._insert(node, this.data.height - node.height - 1, true);
            }

            return this;
        },

        insert: function (item) {
            if (item) this._insert(item, this.data.height - 1);
            return this;
        },

        clear: function () {
            this.data = createNode([]);
            return this;
        },

        remove: function (item, equalsFn) {
            if (!item) return this;

            var node = this.data,
                bbox = this.toBBox(item),
                path = [],
                indexes = [],
                i, parent, index, goingUp;

            // depth-first iterative tree traversal
            while (node || path.length) {

                if (!node) { // go up
                    node = path.pop();
                    parent = path[path.length - 1];
                    i = indexes.pop();
                    goingUp = true;
                }

                if (node.leaf) { // check current node
                    index = findItem(item, node.children, equalsFn);

                    if (index !== -1) {
                        // item found, remove the item and condense tree upwards
                        node.children.splice(index, 1);
                        path.push(node);
                        this._condense(path);
                        return this;
                    }
                }

                if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                    path.push(node);
                    indexes.push(i);
                    i = 0;
                    parent = node;
                    node = node.children[0];

                } else if (parent) { // go right
                    i++;
                    node = parent.children[i];
                    goingUp = false;

                } else node = null; // nothing found
            }

            return this;
        },

        toBBox: function (item) { return item; },

        compareMinX: compareNodeMinX,
        compareMinY: compareNodeMinY,

        toJSON: function () { return this.data; },

        fromJSON: function (data) {
            this.data = data;
            return this;
        },

        _all: function (node, result) {
            var nodesToSearch = [];
            while (node) {
                if (node.leaf) result.push.apply(result, node.children);
                else nodesToSearch.push.apply(nodesToSearch, node.children);

                node = nodesToSearch.pop();
            }
            return result;
        },

        _build: function (items, left, right, height) {

            var N = right - left + 1,
                M = this._maxEntries,
                node;

            if (N <= M) {
                // reached leaf level; return leaf
                node = createNode(items.slice(left, right + 1));
                calcBBox(node, this.toBBox);
                return node;
            }

            if (!height) {
                // target height of the bulk-loaded tree
                height = Math.ceil(Math.log(N) / Math.log(M));

                // target number of root entries to maximize storage utilization
                M = Math.ceil(N / Math.pow(M, height - 1));
            }

            node = createNode([]);
            node.leaf = false;
            node.height = height;

            // split the items into M mostly square tiles

            var N2 = Math.ceil(N / M),
                N1 = N2 * Math.ceil(Math.sqrt(M)),
                i, j, right2, right3;

            multiSelect(items, left, right, N1, this.compareMinX);

            for (i = left; i <= right; i += N1) {

                right2 = Math.min(i + N1 - 1, right);

                multiSelect(items, i, right2, N2, this.compareMinY);

                for (j = i; j <= right2; j += N2) {

                    right3 = Math.min(j + N2 - 1, right2);

                    // pack each entry recursively
                    node.children.push(this._build(items, j, right3, height - 1));
                }
            }

            calcBBox(node, this.toBBox);

            return node;
        },

        _chooseSubtree: function (bbox, node, level, path) {

            var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

            while (true) {
                path.push(node);

                if (node.leaf || path.length - 1 === level) break;

                minArea = minEnlargement = Infinity;

                for (i = 0, len = node.children.length; i < len; i++) {
                    child = node.children[i];
                    area = bboxArea(child);
                    enlargement = enlargedArea(bbox, child) - area;

                    // choose entry with the least area enlargement
                    if (enlargement < minEnlargement) {
                        minEnlargement = enlargement;
                        minArea = area < minArea ? area : minArea;
                        targetNode = child;

                    } else if (enlargement === minEnlargement) {
                        // otherwise choose one with the smallest area
                        if (area < minArea) {
                            minArea = area;
                            targetNode = child;
                        }
                    }
                }

                node = targetNode || node.children[0];
            }

            return node;
        },

        _insert: function (item, level, isNode) {

            var toBBox = this.toBBox,
                bbox = isNode ? item : toBBox(item),
                insertPath = [];

            // find the best node for accommodating the item, saving all nodes along the path too
            var node = this._chooseSubtree(bbox, this.data, level, insertPath);

            // put the item into the node
            node.children.push(item);
            extend(node, bbox);

            // split on node overflow; propagate upwards if necessary
            while (level >= 0) {
                if (insertPath[level].children.length > this._maxEntries) {
                    this._split(insertPath, level);
                    level--;
                } else break;
            }

            // adjust bboxes along the insertion path
            this._adjustParentBBoxes(bbox, insertPath, level);
        },

        // split overflowed node into two
        _split: function (insertPath, level) {

            var node = insertPath[level],
                M = node.children.length,
                m = this._minEntries;

            this._chooseSplitAxis(node, m, M);

            var splitIndex = this._chooseSplitIndex(node, m, M);

            var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
            newNode.height = node.height;
            newNode.leaf = node.leaf;

            calcBBox(node, this.toBBox);
            calcBBox(newNode, this.toBBox);

            if (level) insertPath[level - 1].children.push(newNode);
            else this._splitRoot(node, newNode);
        },

        _splitRoot: function (node, newNode) {
            // split root node
            this.data = createNode([node, newNode]);
            this.data.height = node.height + 1;
            this.data.leaf = false;
            calcBBox(this.data, this.toBBox);
        },

        _chooseSplitIndex: function (node, m, M) {

            var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

            minOverlap = minArea = Infinity;

            for (i = m; i <= M - m; i++) {
                bbox1 = distBBox(node, 0, i, this.toBBox);
                bbox2 = distBBox(node, i, M, this.toBBox);

                overlap = intersectionArea(bbox1, bbox2);
                area = bboxArea(bbox1) + bboxArea(bbox2);

                // choose distribution with minimum overlap
                if (overlap < minOverlap) {
                    minOverlap = overlap;
                    index = i;

                    minArea = area < minArea ? area : minArea;

                } else if (overlap === minOverlap) {
                    // otherwise choose distribution with minimum area
                    if (area < minArea) {
                        minArea = area;
                        index = i;
                    }
                }
            }

            return index;
        },

        // sorts node children by the best axis for split
        _chooseSplitAxis: function (node, m, M) {

            var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
                compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
                xMargin = this._allDistMargin(node, m, M, compareMinX),
                yMargin = this._allDistMargin(node, m, M, compareMinY);

            // if total distributions margin value is minimal for x, sort by minX,
            // otherwise it's already sorted by minY
            if (xMargin < yMargin) node.children.sort(compareMinX);
        },

        // total margin of all possible split distributions where each node is at least m full
        _allDistMargin: function (node, m, M, compare) {

            node.children.sort(compare);

            var toBBox = this.toBBox,
                leftBBox = distBBox(node, 0, m, toBBox),
                rightBBox = distBBox(node, M - m, M, toBBox),
                margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
                i, child;

            for (i = m; i < M - m; i++) {
                child = node.children[i];
                extend(leftBBox, node.leaf ? toBBox(child) : child);
                margin += bboxMargin(leftBBox);
            }

            for (i = M - m - 1; i >= m; i--) {
                child = node.children[i];
                extend(rightBBox, node.leaf ? toBBox(child) : child);
                margin += bboxMargin(rightBBox);
            }

            return margin;
        },

        _adjustParentBBoxes: function (bbox, path, level) {
            // adjust bboxes along the given tree path
            for (var i = level; i >= 0; i--) {
                extend(path[i], bbox);
            }
        },

        _condense: function (path) {
            // go through the path, removing empty nodes and updating bboxes
            for (var i = path.length - 1, siblings; i >= 0; i--) {
                if (path[i].children.length === 0) {
                    if (i > 0) {
                        siblings = path[i - 1].children;
                        siblings.splice(siblings.indexOf(path[i]), 1);

                    } else this.clear();

                } else calcBBox(path[i], this.toBBox);
            }
        },

        _initFormat: function (format) {
            // data format (minX, minY, maxX, maxY accessors)

            // uses eval-type function compilation instead of just accepting a toBBox function
            // because the algorithms are very sensitive to sorting functions performance,
            // so they should be dead simple and without inner calls

            var compareArr = ['return a', ' - b', ';'];

            this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
            this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

            this.toBBox = new Function('a',
                'return {minX: a' + format[0] +
                ', minY: a' + format[1] +
                ', maxX: a' + format[2] +
                ', maxY: a' + format[3] + '};');
        }
    };

    function findItem(item, items, equalsFn) {
        if (!equalsFn) return items.indexOf(item);

        for (var i = 0; i < items.length; i++) {
            if (equalsFn(item, items[i])) return i;
        }
        return -1;
    }

    // calculate node's bbox from bboxes of its children
    function calcBBox(node, toBBox) {
        distBBox(node, 0, node.children.length, toBBox, node);
    }

    // min bounding rectangle of node children from k to p-1
    function distBBox(node, k, p, toBBox, destNode) {
        if (!destNode) destNode = createNode(null);
        destNode.minX = Infinity;
        destNode.minY = Infinity;
        destNode.maxX = -Infinity;
        destNode.maxY = -Infinity;

        for (var i = k, child; i < p; i++) {
            child = node.children[i];
            extend(destNode, node.leaf ? toBBox(child) : child);
        }

        return destNode;
    }

    function extend(a, b) {
        a.minX = Math.min(a.minX, b.minX);
        a.minY = Math.min(a.minY, b.minY);
        a.maxX = Math.max(a.maxX, b.maxX);
        a.maxY = Math.max(a.maxY, b.maxY);
        return a;
    }

    function compareNodeMinX(a, b) { return a.minX - b.minX; }
    function compareNodeMinY(a, b) { return a.minY - b.minY; }

    function bboxArea(a) { return (a.maxX - a.minX) * (a.maxY - a.minY); }
    function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

    function enlargedArea(a, b) {
        return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
               (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
    }

    function intersectionArea(a, b) {
        var minX = Math.max(a.minX, b.minX),
            minY = Math.max(a.minY, b.minY),
            maxX = Math.min(a.maxX, b.maxX),
            maxY = Math.min(a.maxY, b.maxY);

        return Math.max(0, maxX - minX) *
               Math.max(0, maxY - minY);
    }

    function contains(a, b) {
        return a.minX <= b.minX &&
               a.minY <= b.minY &&
               b.maxX <= a.maxX &&
               b.maxY <= a.maxY;
    }

    function intersects(a, b) {
        return b.minX <= a.maxX &&
               b.minY <= a.maxY &&
               b.maxX >= a.minX &&
               b.maxY >= a.minY;
    }

    function createNode(children) {
        return {
            children: children,
            height: 1,
            leaf: true,
            minX: Infinity,
            minY: Infinity,
            maxX: -Infinity,
            maxY: -Infinity
        };
    }

    // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
    // combines selection algorithm with binary divide & conquer approach

    function multiSelect(arr, left, right, n, compare) {
        var stack = [left, right],
            mid;

        while (stack.length) {
            right = stack.pop();
            left = stack.pop();

            if (right - left <= n) continue;

            mid = left + Math.ceil((right - left) / n / 2) * n;
            quickselect(arr, mid, left, right, compare);

            stack.push(left, mid, mid, right);
        }
    }


    /***/
}),
/* 2 */
/***/ (function (module, exports, __webpack_require__) {

    (function (global, factory) {
        true ? module.exports = factory() :
       undefined;
    }(this, (function () {
        'use strict';

        function quickselect(arr, k, left, right, compare) {
            quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
        }

        function quickselectStep(arr, k, left, right, compare) {

            while (right > left) {
                if (right - left > 600) {
                    var n = right - left + 1;
                    var m = k - left + 1;
                    var z = Math.log(n);
                    var s = 0.5 * Math.exp(2 * z / 3);
                    var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
                    var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
                    var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
                    quickselectStep(arr, k, newLeft, newRight, compare);
                }

                var t = arr[k];
                var i = left;
                var j = right;

                swap(arr, left, k);
                if (compare(arr[right], t) > 0) swap(arr, left, right);

                while (i < j) {
                    swap(arr, i, j);
                    i++;
                    j--;
                    while (compare(arr[i], t) < 0) i++;
                    while (compare(arr[j], t) > 0) j--;
                }

                if (compare(arr[left], t) === 0) swap(arr, left, j);
                else {
                    j++;
                    swap(arr, j, right);
                }

                if (j <= k) left = j + 1;
                if (k <= j) right = j - 1;
            }
        }

        function swap(arr, i, j) {
            var tmp = arr[i];
            arr[i] = arr[j];
            arr[j] = tmp;
        }

        function defaultCompare(a, b) {
            return a < b ? -1 : a > b ? 1 : 0;
        }

        return quickselect;

    })));


    /***/
}),
/* 3 */
/***/ (function (module, exports, __webpack_require__) {

    "use strict";


    function layerFactory(L) {

        var CanvasIconLayer = (L.Layer ? L.Layer : L.Class).extend({

            //Add event listeners to initialized section.
            initialize: function (options) {

                L.setOptions(this, options);
                this._onClickListeners = [];
                this._onHoverListeners = [];
            },

            setOptions: function (options) {

                L.setOptions(this, options);
                return this.redraw();
            },

            redraw: function () {

                this._redraw(true);
            },

            //Multiple layers at a time for rBush performance
            addMarkers: function (markers) {

                var self = this;
                var tmpMark = [];
                var tmpLatLng = [];

                markers.forEach(function (marker) {

                    if (!((marker.options.pane == 'markerPane') && marker.options.icon)) {
                        console.error('Layer isn\'t a marker');
                        return;
                    }

                    var latlng = marker.getLatLng();
                    var isDisplaying = self._map.getBounds().contains(latlng);
                    var s = self._addMarker(marker, latlng, isDisplaying);

                    //Only add to Point Lookup if we are on map
                    if (isDisplaying === true) tmpMark.push(s[0]);

                    tmpLatLng.push(s[1]);
                });

                self._markers.load(tmpMark);
                self._latlngMarkers.load(tmpLatLng);
            },

            //Adds single layer at a time. Less efficient for rBush
            addMarker: function (marker) {

                var self = this;
                var latlng = marker.getLatLng();
                var isDisplaying = self._map.getBounds().contains(latlng);
                var dat = self._addMarker(marker, latlng, isDisplaying);

                //Only add to Point Lookup if we are on map
                if (isDisplaying === true) self._markers.insert(dat[0]);

                self._latlngMarkers.insert(dat[1]);
            },

            addLayer: function (layer) {

                if ((layer.options.pane == 'markerPane') && layer.options.icon) this.addMarker(layer);
                else console.error('Layer isn\'t a marker');
            },

            addLayers: function (layers) {

                this.addMarkers(layers);
            },

            removeLayer: function (layer) {

                this.removeMarker(layer, true);
            },

            removeMarker: function (marker, redraw) {

                var self = this;

                //If we are removed point
                if (marker["minX"]) marker = marker.data;

                var latlng = marker.getLatLng();
                var isDisplaying = self._map.getBounds().contains(latlng);

                var markerData = {

                    minX: latlng.lng,
                    minY: latlng.lat,
                    maxX: latlng.lng,
                    maxY: latlng.lat,
                    data: marker
                };

                self._latlngMarkers.remove(markerData, function (a, b) {

                    return a.data._leaflet_id === b.data._leaflet_id;
                });

                self._latlngMarkers.total--;
                self._latlngMarkers.dirty++;

                if (isDisplaying === true && redraw === true) {

                    self._redraw(true);
                }
            },

            onAdd: function (map) {

                this._map = map;

                if (!this._canvas) this._initCanvas();

                if (this.options.pane) this.getPane().appendChild(this._canvas);
                else map._panes.overlayPane.appendChild(this._canvas);

                map.on('moveend', this._reset, this);
                map.on('resize', this._reset, this);

                map.on('click', this._executeListeners, this);
                map.on('mousemove', this._executeListeners, this);
            },

            onRemove: function (map) {

                if (this.options.pane) this.getPane().removeChild(this._canvas);
                else map.getPanes().overlayPane.removeChild(this._canvas);

                map.off('click', this._executeListeners, this);
                map.off('mousemove', this._executeListeners, this);

                map.off('moveend', this._reset, this);
                map.off('resize', this._reset, this);
            },

            addTo: function (map) {

                map.addLayer(this);
                return this;
            },

            clearLayers: function () {

                this._latlngMarkers = null;
                this._markers = null;
                this._redraw(true);
            },

            _addMarker: function (marker, latlng, isDisplaying) {

                var self = this;
                //Needed for pop-up & tooltip to work.
                marker._map = self._map;

                //_markers contains Points of markers currently displaying on map
                if (!self._markers) self._markers = new rbush();

                //_latlngMarkers contains Lat\Long coordinates of all markers in layer.
                if (!self._latlngMarkers) {
                    self._latlngMarkers = new rbush();
                    self._latlngMarkers.dirty = 0;
                    self._latlngMarkers.total = 0;
                }

                L.Util.stamp(marker);

                var pointPos = self._map.latLngToContainerPoint(latlng);
                var iconSize = marker.options.icon.options.iconSize;

                var adj_x = iconSize[0] / 2;
                var adj_y = iconSize[1] / 2;
                var ret = [({
                    minX: (pointPos.x - adj_x),
                    minY: (pointPos.y - adj_y),
                    maxX: (pointPos.x + adj_x),
                    maxY: (pointPos.y + adj_y),
                    data: marker
                }), ({
                    minX: latlng.lng,
                    minY: latlng.lat,
                    maxX: latlng.lng,
                    maxY: latlng.lat,
                    data: marker
                })];

                self._latlngMarkers.dirty++;
                self._latlngMarkers.total++;

                //Only draw if we are on map
                if (isDisplaying === true) self._drawMarker(marker, pointPos);

                return ret;
            },

            _drawMarker: function (marker, pointPos) {

                var self = this;

                if (!this._imageLookup) this._imageLookup = {};
                if (!pointPos) {

                    pointPos = self._map.latLngToContainerPoint(marker.getLatLng());
                }

                var iconUrl = marker.options.icon.options.iconUrl;

                if (marker.canvas_img) {

                    self._drawImage(marker, pointPos);
                }
                else {

                    if (self._imageLookup[iconUrl]) {

                        marker.canvas_img = self._imageLookup[iconUrl][0];

                        if (self._imageLookup[iconUrl][1] === false) {

                            self._imageLookup[iconUrl][2].push([marker, pointPos]);
                        }
                        else {

                            self._drawImage(marker, pointPos);
                        }
                    }
                    else {

                        var i = new Image();
                        i.src = iconUrl;
                        marker.canvas_img = i;

                        //Image,isLoaded,marker\pointPos ref
                        self._imageLookup[iconUrl] = [i, false, [[marker, pointPos]]];

                        i.onload = function () {

                            self._imageLookup[iconUrl][1] = true;
                            self._imageLookup[iconUrl][2].forEach(function (e) {

                                self._drawImage(e[0], e[1]);
                            });
                        }
                    }
                }
            },

            _drawImage: function (marker, pointPos) {

                var options = marker.options.icon.options;

                this._context.drawImage(
                    marker.canvas_img,
                    pointPos.x - options.iconAnchor[0],
                    pointPos.y - options.iconAnchor[1],
                    options.iconSize[0],
                    options.iconSize[1]
                );
            },

            _reset: function () {

                var topLeft = this._map.containerPointToLayerPoint([0, 0]);
                L.DomUtil.setPosition(this._canvas, topLeft);

                var size = this._map.getSize();

                this._canvas.width = size.x;
                this._canvas.height = size.y;

                this._redraw();
            },

            _redraw: function (clear) {

                var self = this;

                if (clear) this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
                if (!this._map || !this._latlngMarkers) return;

                var tmp = [];

                //If we are 10% individual inserts\removals, reconstruct lookup for efficiency
                if (self._latlngMarkers.dirty / self._latlngMarkers.total >= .1) {

                    self._latlngMarkers.all().forEach(function (e) {

                        tmp.push(e);
                    });

                    self._latlngMarkers.clear();
                    self._latlngMarkers.load(tmp);
                    self._latlngMarkers.dirty = 0;
                    tmp = [];
                }

                var mapBounds = self._map.getBounds();

                //Only re-draw what we are showing on the map.

                var mapBoxCoords = {

                    minX: mapBounds.getWest(),
                    minY: mapBounds.getSouth(),
                    maxX: mapBounds.getEast(),
                    maxY: mapBounds.getNorth(),
                };

                self._latlngMarkers.search(mapBoxCoords).forEach(function (e) {

                    //Readjust Point Map
                    var pointPos = self._map.latLngToContainerPoint(e.data.getLatLng());

                    var iconSize = e.data.options.icon.options.iconSize;
                    var adj_x = iconSize[0] / 2;
                    var adj_y = iconSize[1] / 2;

                    var newCoords = {
                        minX: (pointPos.x - adj_x),
                        minY: (pointPos.y - adj_y),
                        maxX: (pointPos.x + adj_x),
                        maxY: (pointPos.y + adj_y),
                        data: e.data
                    }

                    tmp.push(newCoords);

                    //Redraw points
                    self._drawMarker(e.data, pointPos);
                });

                //Clear rBush & Bulk Load for performance
                this._markers.clear();
                this._markers.load(tmp);
            },

            _initCanvas: function () {

                this._canvas = L.DomUtil.create('canvas', 'leaflet-canvas-icon-layer leaflet-layer');
                var originProp = L.DomUtil.testProp(['transformOrigin', 'WebkitTransformOrigin', 'msTransformOrigin']);
                this._canvas.style[originProp] = '50% 50%';

                var size = this._map.getSize();
                this._canvas.width = size.x;
                this._canvas.height = size.y;

                this._context = this._canvas.getContext('2d');

                var animated = this._map.options.zoomAnimation && L.Browser.any3d;
                L.DomUtil.addClass(this._canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));
            },

            addOnClickListener: function (listener) {
                this._onClickListeners.push(listener);
            },

            addOnHoverListener: function (listener) {
                this._onHoverListeners.push(listener);
            },

            _executeListeners: function (event) {

                if (!this._markers) return;

                var me = this;
                var x = event.containerPoint.x;
                var y = event.containerPoint.y;

                if (me._openToolTip) {

                    me._openToolTip.closeTooltip();
                    delete me._openToolTip;
                }

                var ret = this._markers.search({ minX: x, minY: y, maxX: x, maxY: y });

                if (ret && ret.length > 0) {

                    me._map._container.style.cursor = "pointer";

                    if (event.type === "click") {

                        var hasPopup = ret[0].data.getPopup();
                        if (hasPopup) ret[0].data.openPopup();

                        me._onClickListeners.forEach(function (listener) { listener(event, ret); });
                    }

                    if (event.type === "mousemove") {
                        var hasTooltip = ret[0].data.getTooltip();
                        if (hasTooltip) {
                            me._openToolTip = ret[0].data;
                            ret[0].data.openTooltip();
                        }

                        me._onHoverListeners.forEach(function (listener) { listener(event, ret); });
                    }
                }
                else {

                    me._map._container.style.cursor = "";
                }
            }
        });

        L.canvasIconLayer = function (options) {
            return new CanvasIconLayer(options);
        };
    };

    module.exports = layerFactory;


    /***/
})
]);